// import { Sequelize } from 'sequelize';
// import logger from '../middleware/logger.js';
// import dotenv from 'dotenv';

// dotenv.config();

// const isTest = process.env.NODE_ENV === 'test';

// if (!process.env.DB_NAME || !process.env.DB_USER || !process.env.DB_PASSWORD) {
//   throw new Error('Missing database configuration in environment variables');
// }

// const sequelize = new Sequelize(
//   process.env.DB_NAME,
//   process.env.DB_USER,
//   process.env.DB_PASSWORD,
//   {
//     host: process.env.DB_HOST || 'localhost',
//     port: process.env.DB_PORT || 5432,
//     dialect: 'postgres',
//     logging: isTest ? false : msg => logger.debug(msg),
//   }
// );

// export const connectDB = async () => {
//   try {
//     await sequelize.authenticate();
//     await sequelize.sync();
//     logger.info('PostgreSQL Connected');
//   } catch (error) {
//     logger.error(`PostgreSQL Connection Error: ${error.message}`, { error });
//     console.log('PostgreSQL Connection Error:', error);
//     process.exit(1);
//   }
// };

// export default sequelize;
import { Sequelize } from 'sequelize';
import logger from '../middleware/logger.js';
import dotenv from 'dotenv';

// Charger les variables d'environnement
dotenv.config();

// Configuration des environnements
const isTest = process.env.NODE_ENV === 'test';
const isDevelopment = process.env.NODE_ENV === 'development';
const isProduction = process.env.NODE_ENV === 'production';

// Configuration par d√©faut avec validation
const getDbConfig = () => {
  const config = {
    database: process.env.DB_NAME,
    username: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT) || 5432,
    dialect: 'postgres'
  };

  // Validation des variables obligatoires
  const requiredVars = ['DB_NAME', 'DB_USER'];
  const missingVars = requiredVars.filter(varName => !process.env[varName]);
  
  if (missingVars.length > 0) {
    logger.error(`‚ùå Missing required environment variables: ${missingVars.join(', ')}`);
    logger.error('üí° Please check your .env file and ensure these variables are set:');
    missingVars.forEach(varName => {
      logger.error(`   ${varName}=your_value_here`);
    });
    throw new Error(`Missing database configuration: ${missingVars.join(', ')}`);
  }

  // Avertissement pour mot de passe manquant (peut √™tre vide en d√©veloppement)
  if (!process.env.DB_PASSWORD && isProduction) {
    throw new Error('DB_PASSWORD is required in production environment');
  }

  if (!process.env.DB_PASSWORD && !isProduction) {
    logger.warn('‚ö†Ô∏è  DB_PASSWORD is not set (OK for development with trust authentication)');
  }

  return config;
};

// R√©cup√©ration de la configuration
const dbConfig = getDbConfig();

// Configuration Sequelize avec options optimis√©es
const sequelizeOptions = {
  host: dbConfig.host,
  port: dbConfig.port,
  dialect: dbConfig.dialect,
  
  // Logging configur√© selon l'environnement
  logging: isTest ? false : 
          isDevelopment ? (msg) => logger.debug(msg) : 
          false,
  
  // Pool de connexions optimis√©
  pool: {
    max: isProduction ? 20 : 5,      // Plus de connexions en prod
    min: 0,
    acquire: 30000,                   // 30 secondes pour acqu√©rir une connexion
    idle: 10000,                      // 10 secondes avant fermeture d'une connexion inactive
    evict: 1000,                      // V√©rification des connexions inactives chaque seconde
  },
  
  // Configuration des mod√®les par d√©faut
  define: {
    timestamps: true,
    underscored: false,
    freezeTableName: false,
    paranoid: false,                  // Soft delete d√©sactiv√© par d√©faut
  },
  
  // Options de connexion PostgreSQL
  dialectOptions: {
    connectTimeout: 60000,            // 60 secondes pour la connexion
    requestTimeout: 30000,            // 30 secondes pour les requ√™tes
    ...(isProduction && {
      ssl: {
        require: true,
        rejectUnauthorized: false     // Pour les certificats auto-sign√©s
      }
    })
  },
  
  // Retry automatique
  retry: {
    max: 3,
    timeout: 5000,
    match: [
      /ETIMEDOUT/,
      /EHOSTUNREACH/,
      /ECONNRESET/,
      /ECONNREFUSED/,
      /TIMEOUT/,
    ]
  }
};

// Cr√©ation de l'instance Sequelize
const sequelize = new Sequelize(
  dbConfig.database,
  dbConfig.username,
  dbConfig.password,
  sequelizeOptions
);

// Fonction pour cr√©er la base de donn√©es si elle n'existe pas
const createDatabaseIfNotExists = async () => {
  if (process.env.DB_AUTO_CREATE !== 'true') {
    return; // Ne pas cr√©er automatiquement si pas explicitement demand√©
  }

  logger.info('üîç Checking if database exists...');
  
  // Connexion √† la base de donn√©es par d√©faut pour cr√©er la DB cible
  const adminSequelize = new Sequelize(
    'postgres', // Base de donn√©es par d√©faut PostgreSQL
    dbConfig.username,
    dbConfig.password,
    {
      ...sequelizeOptions,
      logging: false // Pas de log pour les op√©rations admin
    }
  );

  try {
    await adminSequelize.authenticate();
    
    // V√©rifier si la base de donn√©es existe
    const [results] = await adminSequelize.query(
      'SELECT 1 FROM pg_database WHERE datname = $1',
      {
        bind: [dbConfig.database],
        type: Sequelize.QueryTypes.SELECT
      }
    );

    if (results.length === 0) {
      logger.info(`üìù Creating database: ${dbConfig.database}`);
      await adminSequelize.query(`CREATE DATABASE "${dbConfig.database}"`);
      logger.info('‚úÖ Database created successfully');
    } else {
      logger.info('‚úÖ Database already exists');
    }
    
  } catch (error) {
    logger.warn(`‚ö†Ô∏è  Could not auto-create database: ${error.message}`);
    logger.info('üí° You may need to create the database manually:');
    logger.info(`   CREATE DATABASE "${dbConfig.database}";`);
  } finally {
    await adminSequelize.close();
  }
};

// Fonction pour g√©rer les ENUMs PostgreSQL
const handlePostgreSQLEnums = async () => {
  try {
    // Cr√©er les ENUMs n√©cessaires s'ils n'existent pas
    const enumQueries = [
      `
        DO $$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'enum_Users_role') THEN
                CREATE TYPE "public"."enum_Users_role" AS ENUM('user', 'admin');
            END IF;
        END$$;
      `
    ];

    for (const query of enumQueries) {
      await sequelize.query(query);
    }
    
    logger.debug('‚úÖ PostgreSQL ENUMs handled successfully');
  } catch (error) {
    logger.warn('‚ö†Ô∏è  Could not create ENUMs:', error.message);
    logger.info('üí° This might cause issues with ENUM fields in your models');
  }
};

// Fonction principale de connexion
export const connectDB = async () => {
  try {
    logger.info('üîÑ Connecting to PostgreSQL database...');
    logger.info(`üìç Connection details: ${dbConfig.username}@${dbConfig.host}:${dbConfig.port}/${dbConfig.database}`);
    
    // √âtape 1: Cr√©er la base de donn√©es si n√©cessaire
    await createDatabaseIfNotExists();
    
    // √âtape 2: Tester la connexion
    await sequelize.authenticate();
    logger.info('‚úÖ Database connection established successfully');
    
    // √âtape 3: G√©rer les ENUMs PostgreSQL
    await handlePostgreSQLEnums();
    logger.info('‚úÖ g√®re les enums');

    
    // √âtape 4: Synchroniser les mod√®les
    const syncOptions = {
      // En d√©veloppement, on peut utiliser alter pour mettre √† jour les tables
      alter: isDevelopment && process.env.DB_ALTER_TABLES === 'true',
      // Force recr√©ation seulement si explicitement demand√© (DANGER en prod!)
      force: isDevelopment && process.env.DB_FORCE_SYNC === 'true'
    };
    
    if (syncOptions.force) {
      logger.warn('‚ö†Ô∏è  FORCE SYNC enabled - This will DROP and RECREATE all tables!');
    }
    
    // await sequelize.sync(syncOptions);
    
    if (syncOptions.alter) {
      logger.info('üîÑ Database schema updated (ALTER mode)');
    } else if (syncOptions.force) {
      logger.info('üîÑ Database schema recreated (FORCE mode)');
    } else {
      logger.info('‚úÖ Database schema validated');
    }
    
    // √âtape 5: Log des informations de connexion
    const dbVersion = await sequelize.query('SELECT version()', { 
      type: Sequelize.QueryTypes.SELECT 
    });
    logger.info(`üìä PostgreSQL version: ${dbVersion[0].version.split(' ')[1]}`);
    
    // Compter les tables existantes
    const [tables] = await sequelize.query(
      "SELECT COUNT(*) as count FROM information_schema.tables WHERE table_schema = 'public'"
    );
    logger.info(`üìã Database contains ${tables[0].count} tables`);
    
    logger.info('üéâ Database initialization completed successfully');
    
  } catch (error) {
    logger.error(`‚ùå PostgreSQL Connection Error: ${error.message}`);
    
    // Diagnostic avanc√© selon le type d'erreur
    if (error.message.includes('ECONNREFUSED')) {
      logger.error('üí° PostgreSQL server is not running. Start it with:');
      logger.error('   ‚Ä¢ Windows: net start postgresql');
      logger.error('   ‚Ä¢ macOS: brew services start postgresql');
      logger.error('   ‚Ä¢ Linux: sudo systemctl start postgresql');
      logger.error('   ‚Ä¢ Docker: docker start postgres-container');
    } else if (error.message.includes('authentication failed')) {
      logger.error('üí° Authentication failed. Check your credentials:');
      logger.error(`   ‚Ä¢ Username: ${dbConfig.username}`);
      logger.error('   ‚Ä¢ Password: Check DB_PASSWORD in .env');
      logger.error('   ‚Ä¢ Try: psql -U ' + dbConfig.username + ' -d postgres');
    } else if (error.message.includes('database') && error.message.includes('does not exist')) {
      logger.error('üí° Database does not exist. Solutions:');
      logger.error(`   ‚Ä¢ Set DB_AUTO_CREATE=true in .env`);
      logger.error(`   ‚Ä¢ Or create manually: CREATE DATABASE "${dbConfig.database}";`);
    } else if (error.message.includes('timeout')) {
      logger.error('üí° Connection timeout. Check:');
      logger.error('   ‚Ä¢ Network connectivity');
      logger.error('   ‚Ä¢ PostgreSQL server status');
      logger.error('   ‚Ä¢ Firewall settings');
    }
    
    logger.error('üîß For more help, run: npm run db:diagnose');
    
    // En d√©veloppement, on peut √™tre moins strict
    if (!isProduction && process.env.DB_IGNORE_ERRORS === 'true') {
      logger.warn('‚ö†Ô∏è  Continuing despite database errors (DB_IGNORE_ERRORS=true)');
      return;
    }
    
    throw error;
  }
};

// Fonction pour fermer proprement la connexion
export const closeDB = async () => {
  try {
    await sequelize.close();
    logger.info('‚úÖ Database connection closed');
  } catch (error) {
    logger.error('‚ùå Error closing database connection:', error.message);
  }
};

// Fonction pour v√©rifier la sant√© de la base de donn√©es
export const checkDBHealth = async () => {
  try {
    await sequelize.authenticate();
    const startTime = Date.now();
    await sequelize.query('SELECT 1');
    const responseTime = Date.now() - startTime;
    
    return {
      status: 'healthy',
      responseTime: `${responseTime}ms`,
      connections: {
        active: sequelize.connectionManager.pool.size,
        idle: sequelize.connectionManager.pool.available.length,
        total: sequelize.connectionManager.pool.options.max
      }
    };
  } catch (error) {
    return {
      status: 'unhealthy',
      error: error.message
    };
  }
};

// Gestion propre de l'arr√™t de l'application
process.on('SIGINT', async () => {
  logger.info('üõë Received SIGINT, closing database connection...');
  await closeDB();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  logger.info('üõë Received SIGTERM, closing database connection...');
  await closeDB();
  process.exit(0);
});

// Export par d√©faut
export default sequelize;